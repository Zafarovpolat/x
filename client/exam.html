<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Помощник для экзамена</title>
    <link rel="stylesheet" href="style.css">
</head>
<body>
    <div class="container">
        <div id="auth-check">
            <h2>Требуется авторизация</h2>
            <p>Пожалуйста, <a href="index.html">войдите</a> для доступа к помощнику.</p>
        </div>

        <div id="clients" style="display: none;">
            <h2>Помощник для экзамена</h2>
            <div id="clients-list"></div>
        </div>
    </div>

    <script>
        const socket = new WebSocket('wss://x-q63z.onrender.com');
        const clientsData = new Map();

        function createClientSection(clientId, userInfo, timer, questions) {
            const clientsList = document.getElementById('clients-list');
            // Проверяем, не существует ли уже секция для этого clientId
            if (document.querySelector(`.client-section[data-client-id="${clientId}"]`)) {
                console.log(`Секция для clientId ${clientId} уже существует, обновляем вместо создания`);
                updateClientSection(clientId, timer, questions);
                return;
            }

            const clientSection = document.createElement('div');
            clientSection.className = 'client-section';
            clientSection.setAttribute('data-client-id', clientId);

            const header = document.createElement('div');
            header.className = 'client-header';
            header.innerHTML = `
                <button>
                    ${userInfo || 'Пользователь ' + clientId} <span class="timer">${timer || '00:00:00'}</span>
                </button>
            `;

            const questionsDiv = document.createElement('div');
            questionsDiv.className = 'questions';
            questionsDiv.style.display = 'none';
            (questions || []).forEach(q => {
                const questionDiv = document.createElement('div');
                questionDiv.className = 'question';
                questionDiv.innerHTML = `
                    <p>${q.question || 'Вопрос не указан'}</p>
                    ${q.questionImg ? `<img src="${q.questionImg}" alt="Question Image">` : ''}
                    <ul>
                        ${q.answers && q.answers.length > 0 ? q.answers.map((ans, i) => `
                            <li>
                                <label class="${q.userAnswer && q.userAnswer.varIndex === i ? 'user-answer' : ''}">
                                    <input type="radio" name="answer-${clientId}-${q.qIndex}" value="${i}">
                                    ${ans.text || 'Ответ не указан'}
                                    ${ans.img ? `<img src="${ans.img}" class="answer-img" alt="Answer Image">` : ''}
                                </label>
                            </li>
                        `).join('') : '<li>Ответы не загружены</li>'}
                    </ul>
                `;
                questionsDiv.appendChild(questionDiv);
            });

            header.querySelector('button').addEventListener('click', () => {
                questionsDiv.style.display = questionsDiv.style.display === 'block' ? 'none' : 'block';
            });

            clientSection.appendChild(header);
            clientSection.appendChild(questionsDiv);
            clientsList.appendChild(clientSection);

            clientsData.set(clientId, { userInfo, timer, questions: questions || [] });
            console.log(`Создана секция для clientId ${clientId}`, clientsData.get(clientId));
        }

        function updateClientSection(clientId, timer, questions) {
            const clientSection = document.querySelector(`.client-section[data-client-id="${clientId}"]`);
            if (clientSection) {
                const timerSpan = clientSection.querySelector('.timer');
                timerSpan.textContent = timer || '00:00:00';

                const questionsDiv = clientSection.querySelector('.questions');
                questionsDiv.innerHTML = '';
                (questions || []).forEach(q => {
                    const questionDiv = document.createElement('div');
                    questionDiv.className = 'question';
                    questionDiv.innerHTML = `
                        <p>${q.question || 'Вопрос не указан'}</p>
                        ${q.questionImg ? `<img src="${q.questionImg}" alt="Question Image">` : ''}
                        <ul>
                            ${q.answers && q.answers.length > 0 ? q.answers.map((ans, i) => `
                                <li>
                                    <label class="${q.userAnswer && q.userAnswer.varIndex === i ? 'user-answer' : ''}">
                                        <input type="radio" name="answer-${clientId}-${q.qIndex}" value="${i}">
                                        ${ans.text || 'Ответ не указан'}
                                        ${ans.img ? `<img src="${ans.img}" class="answer-img" alt="Answer Image">` : ''}
                                    </label>
                                </li>
                            `).join('') : '<li>Ответы не загружены</li>'}
                        </ul>
                    `;
                    questionsDiv.appendChild(questionDiv);
                });

                const clientData = clientsData.get(clientId) || { userInfo: 'Пользователь ' + clientId, questions: [] };
                clientsData.set(clientId, { ...clientData, timer, questions: questions || [] });
                console.log(`Обновлена секция для clientId ${clientId}`, clientsData.get(clientId));
            } else {
                console.log(`Секция для clientId ${clientId} не найдена, создаем новую`);
                createClientSection(clientId, clientsData.get(clientId)?.userInfo || 'Пользователь ' + clientId, timer, questions);
            }
        }

        socket.onopen = () => {
            console.log('WebSocket подключен (exam)');
            socket.send(JSON.stringify({ role: 'exam' }));

            const isAuthenticated = localStorage.getItem('isAuthenticated') === 'true';
            if (isAuthenticated) {
                document.getElementById('auth-check').style.display = 'none';
                document.getElementById('clients').style.display = 'block';
            }
        };

        socket.onmessage = event => {
            try {
                const data = JSON.parse(event.data);
                console.log('Получено сообщение:', data);

                if (data.type === 'initialState') {
                    data.exams.forEach(exam => {
                        createClientSection(exam.clientId, exam.userInfo, exam.timer, exam.questions || []);
                    });
                }

                if (data.type === 'clientDisconnected') {
                    const clientSection = document.querySelector(`.client-section[data-client-id="${data.clientId}"]`);
                    if (clientSection) {
                        clientSection.remove();
                        clientsData.delete(data.clientId);
                        console.log(`Удалена секция для clientId ${data.clientId}`);
                    }
                }

                if (data.type === 'timerUpdate') {
                    const clientData = clientsData.get(data.clientId);
                    if (clientData) {
                        updateClientSection(data.clientId, data.timer, clientData.questions);
                    }
                }

                if (data.type === 'question' || data.type === 'userAnswer') {
                    const clientData = clientsData.get(data.clientId) || { questions: [], userInfo: data.userInfo };
                    let questions = clientData.questions ? [...clientData.questions] : [];

                    const existingQuestionIndex = questions.findIndex(q => q.qIndex === data.qIndex);
                    const questionData = {
                        qIndex: data.qIndex,
                        question: data.question || 'Вопрос не указан',
                        questionImg: data.questionImg,
                        answers: data.answers || [],
                        userAnswer: data.type === 'userAnswer' ? { answer: data.answer, varIndex: data.varIndex } : null
                    };

                    if (existingQuestionIndex !== -1) {
                        questions[existingQuestionIndex] = {
                            ...questions[existingQuestionIndex],
                            question: data.question || questions[existingQuestionIndex].question,
                            questionImg: data.questionImg || questions[existingQuestionIndex].questionImg,
                            answers: data.answers || questions[existingQuestionIndex].answers,
                            userAnswer: data.type === 'userAnswer' ? { answer: data.answer, varIndex: data.varIndex } : questions[existingQuestionIndex].userAnswer
                        };
                    } else {
                        questions.push(questionData);
                    }

                    updateClientSection(data.clientId, data.timer, questions);
                    if (!clientsData.has(data.clientId)) {
                        clientsData.set(data.clientId, { userInfo: data.userInfo, timer: data.timer, questions });
                    }
                }

                document.querySelectorAll('.question input[type="radio"]').forEach(radio => {
                    radio.addEventListener('change', () => {
                        const questionDiv = radio.closest('.question');
                        const clientSection = radio.closest('.client-section');
                        const clientId = clientSection.getAttribute('data-client-id');
                        const qIndex = Array.from(clientSection.querySelectorAll('.question')).indexOf(questionDiv);
                        const varIndex = parseInt(radio.value);
                        const answerText = radio.parentElement.innerText.trim();

                        socket.send(JSON.stringify({
                            answer: answerText,
                            qIndex: qIndex,
                            varIndex: varIndex,
                            clientId: clientId,
                            question: questionDiv.querySelector('p').textContent
                        }));
                    }, { once: true });
                });
            } catch (e) {
                console.error('Ошибка парсинга сообщения:', e);
            }
        };

        socket.onclose = () => {
            console.log('WebSocket закрыт (exam)');
        };
    </script>
</body>
</html>
